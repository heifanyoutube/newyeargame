<!doctype html>
<html lang="zh-Hant">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>一字千金 — Player 書寫端</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/peerjs/1.5.5/peerjs.min.js"></script>
  <style>
    html,body{height:100%;margin:0;background:#071026;color:#e6f0f9;font-family:system-ui,"Noto Sans TC",sans-serif}
    .wrap{display:flex;flex-direction:column;gap:8px;padding:12px;height:100vh;box-sizing:border-box}
    .top{display:flex;gap:8px;align-items:center}
    input,select{padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.06);background:transparent;color:#e6f0f9}
    button{padding:10px 14px;border-radius:10px;border:none;cursor:pointer;background:#ffd166;color:#042036;font-weight:800}
    .canvas-wrap{flex:1;background:#000;border-radius:12px;display:flex;align-items:center;justify-content:center;overflow:hidden}
    canvas{touch-action:none;width:100%;height:100%;}
    .footer{display:flex;gap:8px;align-items:center}
    .small{font-size:13px;color:#9fb3c8}
  </style>
</head>
<body>
  <div class="wrap">
    <div class="top">
      <div style="display:flex;gap:8px;align-items:center">
        <input id="hostId" placeholder="Host ID" />
        <select id="slot">
          <option value="1">Player 1</option>
          <option value="2">Player 2</option>
          <option value="3">Player 3</option>
        </select>
        <input id="name" placeholder="隊名 (例如：A隊)" />
        <button id="join">加入 Host</button>
      </div>
      <div style="margin-left:auto" class="small">注意：需在 HTTPS 下運行以使用瀏覽器手寫 API</div>
    </div>

    <div class="canvas-wrap">
      <canvas id="board"></canvas>
    </div>

    <div class="footer">
      <button id="clear">清除</button>
      <button id="submit" style="background:#36d399">送出答案</button>
      <button id="appeal" style="background:#ff6b6b">請求審核</button>
      <div style="margin-left:auto" class="small">辨識結果：<span id="recognized">—</span></div>
    </div>
  </div>

  <script>
  /*****************
   Player 端功能重點：
   - 連線 Host（輸入 Host ID）
   - 寫字時把筆跡以百分比座標即時傳送給 Host（type:'stroke'）
   - 當按 Submit：嘗試使用瀏覽器 Handwriting Recognition API (navigator.createHandwritingRecognizer)
     若不支援，會把 canvas 轉為影像並使用 Google Cloud Vision REST（需自行填 API_KEY）
   - 可以按「請求審核」傳給 Host（type:'request_review'）
  *****************/

  // 配置
  const PEER_OPTIONS = {}; // 若需自建 PeerServer 可在此填入
  const GOOGLE_CLOUD_VISION_API_KEY = ''; // 若要使用備援 OCR（非必填，若使用請填入）
  const canvas = document.getElementById('board');
  const ctx = canvas.getContext('2d');
  let drawing = false;
  let points = []; // 當前 stroke 的點集合（相對於 canvas）
  let strokesForHost = []; // 每個 stroke 會轉為百分比陣列並傳送
  let peer = null;
  let conn = null;

  function fitCanvas(){
    const wrap = canvas.parentElement;
    canvas.width = wrap.clientWidth * 2; // hi-res backing
    canvas.height = wrap.clientHeight * 2;
    canvas.style.width = '100%';
    canvas.style.height = '100%';
    ctx.lineWidth = 12;
    ctx.lineJoin = 'round';
    ctx.lineCap = 'round';
    ctx.strokeStyle = '#fff';
    ctx.fillStyle='#000';
    ctx.fillRect(0,0,canvas.width,canvas.height);
  }
  window.addEventListener('resize', fitCanvas);
  fitCanvas();

  // Pointer events
  canvas.addEventListener('pointerdown', e=>{
    drawing=true;
    points = [];
    canvas.setPointerCapture(e.pointerId);
    addPoint(e);
  });
  canvas.addEventListener('pointermove', e=>{
    if (!drawing) return;
    addPoint(e);
    drawCurrent();
  });
  canvas.addEventListener('pointerup', e=>{
    if (!drawing) return;
    drawing=false;
    addPoint(e);
    commitStroke();
    drawCurrent();
  });
  function addPoint(e){
    const rect = canvas.getBoundingClientRect();
    const px = (e.clientX - rect.left) * (canvas.width / rect.width);
    const py = (e.clientY - rect.top) * (canvas.height / rect.height);
    points.push({x:px, y:py, t: Date.now()});
  }
  function drawCurrent(){
    // redraw last stroke on overlay
    // For performance we keep cumulative drawing on canvas itself
    if (!points || points.length===0) return;
    ctx.beginPath();
    ctx.moveTo(points[0].x, points[0].y);
    for (let i=1;i<points.length;i++) ctx.lineTo(points[i].x, points[i].y);
    ctx.stroke();
  }
  function commitStroke(){
    // store stroke as percent coords to send
    const strokePercent = points.map(pt=>({x: pt.x / canvas.width, y: pt.y / canvas.height}));
    strokesForHost.push(strokePercent);
    // send to host immediately (for real-time sync)
    if (conn && conn.open) conn.send({type:'stroke', points: strokePercent, width: 6, color:'#ffffff'});
  }

  document.getElementById('clear').addEventListener('click', ()=>{
    ctx.clearRect(0,0,canvas.width,canvas.height);
    ctx.fillStyle='#000'; ctx.fillRect(0,0,canvas.width,canvas.height);
    strokesForHost=[];
    if (conn && conn.open) conn.send({type:'clear'});
  });

  // Join Host
  document.getElementById('join').addEventListener('click', ()=>{
    const hid = document.getElementById('hostId').value.trim();
    const slot = parseInt(document.getElementById('slot').value,10);
    const name = (document.getElementById('name').value||`Player${slot}`).trim();
    if (!hid) return alert('請輸入 Host ID');
    peer = new Peer(undefined, PEER_OPTIONS);
    peer.on('open', id => console.log('my peer id:', id));
    conn = peer.connect(hid);
    conn.on('open', ()=>{
      conn.send({type:'init', role:'player', slot, name});
      alert('已連線 Host，開始比賽時請等待 Admin 出題');
      conn.on('data', onHostData);
    });
    conn.on('error', e=> console.error('conn error',e));
  });

  // Host data handler
  async function onHostData(msg){
    if (!msg || !msg.type) return;
    if (msg.type === 'new_question') {
      // 清畫布、解鎖書寫
      ctx.clearRect(0,0,canvas.width,canvas.height); ctx.fillStyle='#000'; ctx.fillRect(0,0,canvas.width,canvas.height);
      strokesForHost=[];
      document.getElementById('recognized').textContent = '—';
      alert('新題目：' + msg.q);
    } else if (msg.type === 'time_up') {
      alert('時間到！請立即送出或等待系統判定。');
    } else if (msg.type === 'judgement' || msg.type === 'override_result') {
      // host->player judgement (handled by player UI if needed)
      console.log('host judgement', msg);
    }
  }

  // Submit (辨識與送出)
  document.getElementById('submit').addEventListener('click', async ()=>{
    const recognized = await recognizeInk();
    document.getElementById('recognized').textContent = recognized || '(無)';
    if (conn && conn.open) conn.send({type:'submit', recognized});
  });

  // Appeal
  document.getElementById('appeal').addEventListener('click', ()=>{
    if (conn && conn.open) conn.send({type:'request_review'});
    alert('已發出申訴請求，請等待 Admin 覆核');
  });

  // Handwriting recognition: 優先使用瀏覽器 Handwriting Recognition API（若支援）
  async function recognizeInk(){
    // If WICG Handwriting API is available
    if ('createHandwritingRecognizer' in navigator) {
      try {
        const recognizer = await navigator.createHandwritingRecognizer({languages:['zh-Hant','zh-TW','zh']});
        const drawing = recognizer.startDrawing({recognitionType:'text', inputType:['touch','pen','mouse']});
        // Convert our strokesForHost to HandwritingStroke objects by replaying points
        // The API expects HandwritingStroke instances; create them and add points
        for (const stroke of strokesForHost){
          const hstroke = new HandwritingStroke();
          const startTime = Date.now();
          stroke.forEach((p, idx) => {
            // p are percentage coords relative to canvas size — convert to actual px for API
            const x = p.x * canvas.width;
            const y = p.y * canvas.height;
            const t = idx*10; // relative timestamp (ms) — approximate
            hstroke.addPoint({x, y, t});
          });
          drawing.addStroke(hstroke);
        }
        // getPrediction returns an array of predictions
        const preds = await drawing.getPrediction();
        const best = preds && preds[0] ? preds[0].text : '';
        // cleanup
        drawing.clear();
        recognizer.finish();
        return best;
      } catch (e){
        console.warn('Handwriting API failed, fallback to image OCR', e);
      }
    }

    // Fallback: use Google Cloud Vision OCR (DOCUMENT_TEXT_DETECTION) if API key provided.
    if (GOOGLE_CLOUD_VISION_API_KEY) {
      try {
        // take snapshot
        const dataUrl = canvas.toDataURL('image/png');
        const body = {
          requests: [{
            image: { content: dataUrl.split(',')[1] },
            features: [{ type: 'DOCUMENT_TEXT_DETECTION', maxResults: 1 }]
          }]
        };
        const res = await fetch(`https://vision.googleapis.com/v1/images:annotate?key=${GOOGLE_CLOUD_VISION_API_KEY}`, {
          method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify(body)
        });
        const j = await res.json();
        const text = j?.responses?.[0]?.fullTextAnnotation?.text || (j?.responses?.[0]?.textAnnotations?.[0]?.description || '');
        return (text || '').split('\n').join('').trim();
      } catch (e){
        console.error('Vision API error', e);
        return '';
      }
    }

    // 最後的最後：嘗試用最簡單的 canvas->image->OCR 但不實作（提示用戶）
    alert('此裝置不支援瀏覽器手寫 API，且未設定 Google Vision API KEY，請在支援的 Chrome 或設定 API KEY 後重試。');
    return '';
  }

  // Safety: Peer errors
  window.addEventListener('unload', ()=> { if (peer) peer.destroy(); });
  </script>
</body>
</html>
